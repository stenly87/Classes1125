// Тема: Классы в c#
// класс - ссылочный тип данных
// может содержать в себе разные значения
// других типов данных
// также содержит несколько конструкций
namespace Classes;

class Program
{
    public static void Main()
    { 
        // объект это переменная, проинициализированная 
        // определенным классом
        // объект класса часто называют экземпляром
        // каждый экземпляр класса уникальный, поскольку 
        // содержит свой набор данных
        /*Student student = new Student();
        Student sameStudent = student; // вторая ссылка на тот же объект

        bool isEqual = student.Equals(sameStudent); // true
        Console.WriteLine(student.ToString());

        student.age = 20; // за счет модификатор internal 
        student.PrintAge();// мы получаем доступ к полю и методу*/

        Father father = new Father();
        father.FirstName = "Антон";
        Mother mother = new Mother();
        mother.FirstName = "Антонина";
        Children children = new Children();
        children.FirstName = "Антонио";
        // назначение объектов может выглять так. НО
        // это небезопасно
        father.Childrens.Add(children);
        mother.Childrens.Add(children);

        children.Father = father;
        children.Mother = mother;

        Children child = new Children();
        child.FirstName = "Армен";

        child.Mother = mother;
        //mother.Childrens.Add(child); допустим мы забыли эту строку
        //итог: Армен знает, что у него есть мать, а мать про это не знает
        // Санта Барбара
        father.Childrens.Add(child);
        // child.Father = father; если мы забыли сделать и так
        // то отец знает про сына, а тот про отца не вкурсе
        // Санта Барбара 2
        // т.е. у полей, доступных извне есть проблема безопасности

        Father anotherFather = new Father();
        anotherFather.FirstName = "Си Си";
        anotherFather.Childrens.Add(child); // Си Си тоже считает 
                                            // Армена сыном
                                            // Армен все еще про это не знает
                                            // Антонина вообще не знает ни про одного отца кстати
                                            // Санта Барбара 3
        children.Father = anotherFather; // СИ Си стал отцом Армена
        // у полей есть большая проблема безопасности
        // поэтому существуют свойства
        // свойства это завуалированные методы, которые ведут себя
        // как переменные, но при этом им можно контролировать права
        // на чтение или запись, а также можно валидировать значения
        // перед переназначением
        //children.weight = -10; // (пример с полем) с точки зрения здравого смысла это неправильно
        // свойство решит проблему выше проверкой назначаемого значения
        // свойство создает поле для своей работы, либо использует 
        // назначенное поле
        // синтаксис свойства:
        // модификатор тип Название {get;set;}
        // модификатор обычно public или internal
        // get; set; это аксессор и мутатор, которые можно использовать
        // в кратком или полном виде (get; - краткий вид)

        children.Weight = 52;
        Console.WriteLine(children.Weight);
        children.Weight = 250; // значение проигнорируется, но ошибок нет
        Console.WriteLine(children.Weight);
    }
}

// пример пустого класса
// класс содержит данные: поля, свойства
// полное название класса включает в себя все пространства имен
// внутри которых объявлен класс
public class Children
{
    // полем называется переменная,
    // объявленная внутри класса
    // данные, объявленные внутри класса, по умолчанию
    // доступны для всех конструкций внутри класса
    // область видимости переменной по умолчанию
    // ограничена ближайшим телом (т.е скобками: { тело })

    // существуют ключевые слова для изменения уровня доступа 
    // к конструкциям внутри классов (и для самих классов)
    // private - по умолчанию (доступ только внутри класса)
    // protected (доступ внутри класса и внутри классов-потомков)
    // internal (доступ доступен извне класса,
    //          но ограничен пространством имен)
    // public (самый публичный доступ, доступно отовсюду)

    // по соглашению названия полей указывается со строчной буквы
    // или знака подчеркивания
    internal int age;

    // каждый экземпляр класса может содержать разную информацию
    // во всех полях, тем самым характеризуя разных студентов
    public string FirstName;
    public string LastName;
    public DateTime Birthday;
    //public double Weight;
    double weight;
    public double Weight
    {// тело свойства
        get // аксессор, у него свое тело
        {// get должен содержать return
            return weight; // значение, которое мы получим,
            //если обратимся к свойству Weight на чтение
        }
        set // мутатор
        {// может обращаться к получаемому значению с помощью
            // ключевого слова value
            if(value > 0 && value < 200)
                weight = value;
        }
    }

    public Father Father;
    public Mother Mother;

    // если прописать static для метода, он потеряет доступ к полю
    internal /*static*/ void PrintAge()
    {
        int test = 0;
        Console.WriteLine(age);
    }

    // static - объявляет конструкцию внутри класса (или сам класс)
    // как статичный. Статичным конструкциям не нужен экземпляр для
    // работы. Статичные конструкции не имеют доступа к нестатичным.
    // классы, объявленные как static (static class Tools) могут
    // содержать только статичные конструкции
    // поля и свойства, отмеченные как static, имеют только одно
    // значение, независимо от числа экземляров класса (т.е. 
    // все что объявлено статичным, создает единожды при запуске 
    // приложения)
    // конструкции с модификатором public или internal, помеченные
    // как static можно использовать через имя класса (Math.PI,
    // File.OpenRead)
   
}

public class Mother
{
    public string FirstName;
    public string LastName;

    public List<Children> Childrens = new ();
}

public class Father
{
    public string FirstName;
    public string LastName;

    public List<Children> Childrens = new();
}