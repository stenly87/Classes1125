// Тема: Классы в c#
// класс - ссылочный тип данных
// может содержать в себе разные значения
// других типов данных
// также содержит несколько конструкций
namespace Classes;

class Program
{
    public static void Main()
    { 
        // объект это переменная, проинициализированная 
        // определенным классом
        // объект класса часто называют экземпляром
        // каждый экземпляр класса уникальный, поскольку 
        // содержит свой набор данных
        /*Student student = new Student();
        Student sameStudent = student; // вторая ссылка на тот же объект

        bool isEqual = student.Equals(sameStudent); // true
        Console.WriteLine(student.ToString());

        student.age = 20; // за счет модификатор internal 
        student.PrintAge();// мы получаем доступ к полю и методу*/

        Father father = new Father();
        father.FirstName = "Антон";
        Mother mother = new Mother();
        mother.FirstName = "Антонина";
        Children children = new Children { Birthday = DateTime.Parse("01.05.2000") };
        children.FirstName = "Антонио";
        // назначение объектов может выглять так. НО
        // это небезопасно
        father.Childrens.Add(children);
        mother.Childrens.Add(children);

        children.Father = father;
        children.Mother = mother;

        Children child = new Children { Birthday = DateTime.Parse("01.05.2000") };
        child.FirstName = "Армен";

        child.Mother = mother;
        //mother.Childrens.Add(child); допустим мы забыли эту строку
        //итог: Армен знает, что у него есть мать, а мать про это не знает
        // Санта Барбара
        father.Childrens.Add(child);
        // child.Father = father; если мы забыли сделать и так
        // то отец знает про сына, а тот про отца не вкурсе
        // Санта Барбара 2
        // т.е. у полей, доступных извне есть проблема безопасности

        Father anotherFather = new Father();
        anotherFather.FirstName = "Си Си";
        anotherFather.Childrens.Add(child); // Си Си тоже считает 
                                            // Армена сыном
                                            // Армен все еще про это не знает
                                            // Антонина вообще не знает ни про одного отца кстати
                                            // Санта Барбара 3
        children.Father = anotherFather; // СИ Си стал отцом Армена
        // у полей есть большая проблема безопасности
        // поэтому существуют свойства
        // свойства это завуалированные методы, которые ведут себя
        // как переменные, но при этом им можно контролировать права
        // на чтение или запись, а также можно валидировать значения
        // перед переназначением
        //children.weight = -10; // (пример с полем) с точки зрения здравого смысла это неправильно
        // свойство решит проблему выше проверкой назначаемого значения
        // свойство создает поле для своей работы, либо использует 
        // назначенное поле
        // синтаксис свойства:
        // модификатор тип Название {get;set;}
        // модификатор обычно public или internal
        // get; set; это аксессор и мутатор, которые можно использовать
        // в кратком или полном виде (get; - краткий вид)

        children.Weight = 52;
        Console.WriteLine(children.Weight);
        children.Weight = 250; // значение проигнорируется, но ошибок нет
        Console.WriteLine(children.Weight);

        Console.WriteLine(children.Age);

        Car car = new Car();
        car.Mark = "Honda"; // можно переназначить любое свойство
        Console.WriteLine($"{car.Mark} {car.Year} {car.Price}");

        car = new Car("Лада", 2023, 300000);
        Console.WriteLine($"{car.Mark} {car.Year} {car.Price}");
            
        // для работы такого варианта назначения свойств
        // в классе либо не должно быть конструкторов
        // либо должен присутствовать конструктор без аргументов
        // если конструктор есть, то сначала выполнится он,
        // потом произойдет переназначение свойств
        car = new Car { Mark = "Ferrari" };
        Console.WriteLine($"{car.Mark} {car.Year} {car.Price}");

        for (int i = 0; i < 10000; i++)
            car = new Car();

        Console.WriteLine("10 000 объектов созданы");
        Console.ReadLine();
        GC.Collect(); // принудительный вызов сборщика мусора
        Console.ReadLine();
        Console.WriteLine(Car.count + " объектов было уничтожено сборщиком мусора");
        Console.ReadLine();
    }
}

// пример пустого класса
// класс содержит данные: поля, свойства
// полное название класса включает в себя все пространства имен
// внутри которых объявлен класс
public class Children
{
    // полем называется переменная,
    // объявленная внутри класса
    // данные, объявленные внутри класса, по умолчанию
    // доступны для всех конструкций внутри класса
    // область видимости переменной по умолчанию
    // ограничена ближайшим телом (т.е скобками: { тело })

    // существуют ключевые слова для изменения уровня доступа 
    // к конструкциям внутри классов (и для самих классов)
    // private - по умолчанию (доступ только внутри класса)
    // protected (доступ внутри класса и внутри классов-потомков)
    // internal (доступ доступен извне класса,
    //          но ограничен пространством имен)
    // public (самый публичный доступ, доступно отовсюду)

    // по соглашению названия полей указывается со строчной буквы
    // или знака подчеркивания
    //internal int age;

    // каждый экземпляр класса может содержать разную информацию
    // во всех полях, тем самым характеризуя разных студентов
    public string FirstName;
    public string LastName;
    public DateTime Birthday;
    //public double Weight;
    double weight;
    public double Weight
    {// тело свойства
        get // аксессор, у него свое тело
        {// get должен содержать return
            return weight; // значение, которое мы получим,
            //если обратимся к свойству Weight на чтение
        }
        set // мутатор
        {// может обращаться к получаемому значению с помощью
            // ключевого слова value
            if(value > 0 && value < 200)
                weight = value;
        }
    }
    // краткая запись свойства
    // при компиляции будет создано специальное поле,
    // где будет храниться значение свойства
    public bool IsInCollege { get; set; } 

    // в свойстве может отсутствовать один из блоков 
    // (либо get либо set)
    // если есть блок get, то свойство доступно только
    // для чтения. Если есть только блок set, свойство
    // доступно только для записи

    // это свойство доступно только для чтения
    public int Age { 
        get 
        {
            // это очень упрощенный расчет
            return DateTime.Now.Year - Birthday.Year;
        }
    }

    public Father Father;
    public Mother Mother;

    // если прописать static для метода, он потеряет доступ к полю
    internal /*static*/ void PrintAge()
    {
        int test = 0;
        Console.WriteLine(Age);
    }

    // static - объявляет конструкцию внутри класса (или сам класс)
    // как статичный. Статичным конструкциям не нужен экземпляр для
    // работы. Статичные конструкции не имеют доступа к нестатичным.
    // классы, объявленные как static (static class Tools) могут
    // содержать только статичные конструкции
    // поля и свойства, отмеченные как static, имеют только одно
    // значение, независимо от числа экземляров класса (т.е. 
    // все что объявлено статичным, создает единожды при запуске 
    // приложения)
    // конструкции с модификатором public или internal, помеченные
    // как static можно использовать через имя класса (Math.PI,
    // File.OpenRead)
}

public class Mother
{
    public string FirstName;
    public string LastName;

    public List<Children> Childrens = new ();
}

public class Father
{
    public string FirstName;
    public string LastName;

    public List<Children> Childrens = new();
}


public class Car
{
    public static int count = 0;
    // Конструкторы
    // Конструктор выполняется при инициализации объекта класса
    // Разные конструкторы различаются по типу и/или кол-ву 
    // аргументов
    // Какой именно конструктор будет использован при
    // инициализации объекта, будет зависеть от переденных
    // аргументов в объект (синтаксис после слова new)
    // Конструктор может быть объявлен с разным модификатором
    // доступа
    // Может быть статичный конструктор, он может быть
    // только один на класс. Выполняется при первом обращении
    // к классу, т.е. один раз
    // Название конструктора всегда совпадает с названием
    // класса

    public string Mark { get; set; }
    public int Year { get; set; }
    public int Price { get; set; }

    // пример конструктора без аргументов
    // такой же конструктор есть в любом классе
    // без прописанных конструкторов. Только он ничего 
    // не будет делать, просто для соблюдения синтаксиса
    public Car()
    {
        // в конструкторе обычно происходит назначение
        // состояния объекта (значения по умолчанию для 
        // свойств и полей)
        Price = 1000000;
        Year = 2020;
        Mark = "Toyota";
    }

    // далее еще 3 конструктора
    // все 4 конструктора отличаются набором аргументов
    public Car(string mark)
    { 
        Mark = mark;
    }
    // :this - обращение к другому конструктору в этом же
    // классе
    public Car(string mark, int year): this(mark)
    {
        Year = year;
    }

    // вызывается второй конструктор, куда передаются 2
    // аргумента. А второй конструктор, в свою очередь
    // вызывается конструктор с одним аргументом
    public Car(string mark, int year, int price)
        :this(mark, year)
    {
        Price = price;
    }

    // статичный конструктор не имеет модификатора для
    // области видимости. Должно быть слово static
    // отсутствуют аргументы
    static Car()
    {
        Console.WriteLine("Выполнился статичный конструктор");
    }

    // деструктор
    // в фреймворках .net используется специальный сборщик
    // мусора (Garbage Collector, класс GC), который работает
    // автоматически (можно вызвать его вручную через метод
    // GC.Collect()). Сборщик мусора ищет объекты, на которые
    // нет ссылок, т.е. они не используются в системе.
    // найденные объекты уничтожаются. При уничтожении объекта
    // у него срабатывает деструктор. Нельзя точно предсказать
    // когда сработает деструктор.
    // Частая проблема Memory Leak - утечка памяти, как раз
    // связана с тем, что на какие-то объекты всегда есть
    // ссылки, поэтому их нельзя удалить из памяти.
    // пример деструктора, аргументов нет, модификатор доступа
    // нет
    ~Car()
    {
        // в деструкторе не должно быть важного кода
        // обычно очень специфичный код
        //Console.WriteLine("Объект уничтожен");
        count++;
    }
}